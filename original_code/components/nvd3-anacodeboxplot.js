nv.models.anacodeboxPlot = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , color = nv.utils.defaultColor()
        , container = null
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')
        , duration = 250
        , maxBoxWidth = null
        , minBoxWidth = 34  // patched by sfl: added minBoxWidth option
        , subgraphSpace = 76  // patched by sfl: added subgraphSpace option
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom;

            container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x   .domain(xDomain || data.map(function(d,i) { return getX(d,i); }))
                .rangeBands(xRange || [0, availableWidth], .1);

            // if we know yDomain, no need to calculate
            var yData = []
            if (!yDomain) {
                // (y-range is based on quartiles, whiskers and outliers)

                // lower values
                var yMin = d3.min(data.map(function(d) {
                    var min_arr = [];

                    min_arr.push(d.values.Q1);
                    if (d.values.hasOwnProperty('whisker_low') && d.values.whisker_low !== null) { min_arr.push(d.values.whisker_low); }
                    if (d.values.hasOwnProperty('outliers') && d.values.outliers !== null) { min_arr = min_arr.concat(d.values.outliers); }

                    return d3.min(min_arr);
                }));

                // upper values
                var yMax = d3.max(data.map(function(d) {
                    var max_arr = [];

                    max_arr.push(d.values.Q3);
                    if (d.values.hasOwnProperty('whisker_high') && d.values.whisker_high !== null) { max_arr.push(d.values.whisker_high); }
                    if (d.values.hasOwnProperty('outliers') && d.values.outliers !== null) { max_arr = max_arr.concat(d.values.outliers); }

                    return d3.max(max_arr);
                }));

                yData = [ yMin, yMax ] ;
            }

            y.domain(yDomain || yData);
            y.range(yRange || [availableHeight, 0]);

            //store old scales if they exist
            x0 = x0 || x;
            y0 = y0 || y.copy().range([y(0),y(0)]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var boxplots = wrap.selectAll('.nv-boxplot').data(function(d) { return d });
            var boxEnter = boxplots.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);

            boxplots
                .attr('class', 'nv-boxplot')
                // patched by alex: seperate specific graphs by moving them by a space specified through subgraphSpace option
                // .attr('transform', function(d,i,j) { return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05) + ', 0)'; })
                // .attr('transform', function(d,i,j) { return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 +(i>0?100:0)) + ', 0)'; })
                .attr('transform', function(d,i,j) { return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 + (i > 0 ? subgraphSpace : 0)) + ', 0)'; })
                .classed('hover', function(d) { return d.hover });
            boxplots
                .watchTransition(renderWatch, 'nv-boxplot: boxplots')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .75)
                .delay(function(d,i) { return i * duration / data.length })
                .attr('transform', function(d,i) {
                    // patched by alex: seperate specific graphs by moving them by a space specified through subgraphSpace option
                    // return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05) + ', 0)';
                    // return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 +(i>0?100:0)) + ', 0)';
                    return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 + (i > 0 ? subgraphSpace : 0)) + ', 0)';
                });
            boxplots.exit().remove();

            // ----- add the SVG elements for each boxPlot -----

            // conditionally append whisker lines
            boxEnter.each(function(d,i) {
              var box = d3.select(this);

              ['low', 'high'].forEach(function(key) {
                if (d.values.hasOwnProperty('whisker_' + key) && d.values['whisker_' + key] !== null) {
                  box.append('line')
                    .style('stroke', (d.color) ? d.color : color(d,i))
                    .attr('class', 'nv-boxplot-whisker nv-boxplot-' + key);

                  box.append('line')
                    .style('stroke', (d.color) ? d.color : color(d,i))
                    .attr('class', 'nv-boxplot-tick nv-boxplot-' + key);
                }
              });
            });

            // outliers
            // TODO: support custom colors here
            var outliers = boxplots.selectAll('.nv-boxplot-outlier').data(function(d) {
                if (d.values.hasOwnProperty('outliers') && d.values.outliers !== null) { return d.values.outliers; }
                else { return []; }
            });
            outliers.enter().append('circle')
                .style('fill', function(d,i,j) { return color(d,j) }).style('stroke', function(d,i,j) { return color(d,j) })
                .on('mouseover', function(d,i,j) {
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        series: { key: d, color: color(d,j) },
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i,j) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        series: { key: d, color: color(d,j) },
                        e: d3.event
                    });
                })
                .on('mousemove', function(d,i) {
                    dispatch.elementMousemove({e: d3.event});
                });

            outliers.attr('class', 'nv-boxplot-outlier');
            outliers
              .watchTransition(renderWatch, 'nv-boxplot: nv-boxplot-outlier')
                .attr('cx', x.rangeBand() * .45)
                .attr('cy', function(d,i,j) { return y(d); })
                .attr('r', '3');
            outliers.exit().remove();

            // patched by alex: added support for variable width bars.
            // box_width, box_left, box_right now accept the index indicating
            // the bar's width

            // old code:
            // var box_width = function() { return (maxBoxWidth === null ? x.rangeBand() * .9 : Math.min(75, x.rangeBand() * .9)); };
            // var box_left  = function() { return x.rangeBand() * .45 - box_width()/2; };
            // var box_right = function() { return x.rangeBand() * .45 + box_width()/2; };

            // max value for indicating the bar's width (0 = main, 1 = min specific, 5 = max specific)
            var max_barwidth_index = 5;
            var normalised_maxBoxWidth = (maxBoxWidth === null ? x.rangeBand() * .9 : Math.min(75, x.rangeBand() * .9));
            var box_width = function(idx) {return idx > 0 ? ((normalised_maxBoxWidth - minBoxWidth) * (idx / (max_barwidth_index + 1)) + minBoxWidth) : normalised_maxBoxWidth;};
            var box_left  = function(idx) {return x.rangeBand() * .45 - box_width(idx) / 2;};
            var box_right = function(idx) {return x.rangeBand() * .45 + box_width(idx) / 2;};

            // update whisker lines and ticks
            ['low', 'high'].forEach(function(key) {
              var endpoint = (key === 'low') ? 'Q1' : 'Q3';

              boxplots.select('line.nv-boxplot-whisker.nv-boxplot-' + key)
                .watchTransition(renderWatch, 'nv-boxplot: boxplots')
                  .attr('x1', x.rangeBand() * .45 )
                  .attr('y1', function(d,i) { return y(d.values['whisker_' + key]); })
                  .attr('x2', x.rangeBand() * .45 )
                  .attr('y2', function(d,i) { return y(d.values[endpoint]); });

              boxplots.select('line.nv-boxplot-tick.nv-boxplot-' + key)
                .watchTransition(renderWatch, 'nv-boxplot: boxplots')
                  .attr('x1', function(d,i) { return box_left(d.values.width_index); })
                  .attr('y1', function(d,i) { return y(d.values['whisker_' + key]); })
                  .attr('x2', function(d,i) { return box_right(d.values.width_index); })
                  .attr('y2', function(d,i) { return y(d.values['whisker_' + key]); });
            });

            ['low', 'high'].forEach(function(key) {
              boxEnter.selectAll('.nv-boxplot-' + key)
                .on('mouseover', function(d,i,j) {
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        series: { key: d.values['whisker_' + key], color: color(d,j) },
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i,j) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        series: { key: d.values['whisker_' + key], color: color(d,j) },
                        e: d3.event
                    });
                })
                .on('mousemove', function(d,i) {
                    dispatch.elementMousemove({e: d3.event});
                });
            });

            // boxes
            var minor_fadeout = 382, major_fadeout = 618; // patched by sfl: timing settings for transition [see just below]
            boxEnter.append('rect')
                .attr('class', 'nv-boxplot-box')

                // patched by sfl. click handler for transition for switching
                // specific to main graph when clicked
                .on('click', function(d,i) {
                    jQuery('svg, svg *').addClass('dummy'); // this is a fix for an angular bug (related to https://github.com/dotansimha/angularjs-dropdown-multiselect/issues/49)
                    jQuery('.nvtooltip').hide();
                    jQuery('g.nv-axis, g.nv-barsWrap > rect').fadeOut(minor_fadeout);
                    jQuery('g.nv-boxplot').each(function (index, el) {
                        if (index == i) {
                            var start_x = parseInt(jQuery(this).attr('transform').slice(10, -3), 10);
                            jQuery('.graph_button:nth-child(' + (index + 1) + ')').fadeOut(minor_fadeout);
                            jQuery(el)
                                .data('src_x', jQuery(el).attr('transform'))
                                .animate({
                                    'text-index': 100 // improvised 0 - 100 counter. also: wont animate without any property.
                                }, {
                                    duration: major_fadeout,
                                    step: function(now, fx) {
                                        jQuery(this).attr('transform', 'translate(' + (start_x - ~~(start_x * now / 100)) + ',0)');
                                        if (now > 76.4) {
                                            jQuery(el).fadeTo(0.001, (100 - now) / 10);
                                        }
                                    },
                                    complete: function () {
                                        jQuery('.graph_button:nth-child(' + (index + 1) + ') ul li:first-child a').click();
                                    }
                                });
                        } else {
                            jQuery(el).fadeOut(minor_fadeout, function () {jQuery(this).hide();});
                            jQuery('.graph_button:nth-child(' + (index + 1) + ')').fadeOut(minor_fadeout, function () {jQuery(this).hide();});
                        }
                    });
                    updateScrollArrows();
                })

                // tooltip events
                .on('mouseover', function(d,i) {
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        key: d.label,
                        value: d.label,
                        series: [
                            { key: 'Q3', value: d.values.Q3, color: d.color || color(d,i) },
                            { key: 'Q2', value: d.values.Q2, color: d.color || color(d,i) },
                            { key: 'Q1', value: d.values.Q1, color: d.color || color(d,i) }
                        ],
                        data: d,
                        index: i,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        key: d.label,
                        value: d.label,
                        series: [
                            { key: 'Q3', value: d.values.Q3, color: d.color || color(d,i) },
                            { key: 'Q2', value: d.values.Q2, color: d.color || color(d,i) },
                            { key: 'Q1', value: d.values.Q1, color: d.color || color(d,i) }
                        ],
                        data: d,
                        index: i,
                        e: d3.event
                    });
                })
                .on('mousemove', function(d,i) {
                    dispatch.elementMousemove({e: d3.event});
                });

            // box transitions
            boxplots.select('rect.nv-boxplot-box')
              .watchTransition(renderWatch, 'nv-boxplot: boxes')
                .attr('y', function(d,i) { return y(d.values.Q3); })
                .attr('width', function(d,i) { return box_width(d.values.width_index); })
                .attr('x', function(d,i) { return box_left(d.values.width_index); })

                .attr('height', function(d,i) { return Math.abs(y(d.values.Q3) - y(d.values.Q1)) || 1 })
                .style('fill', function(d,i) { return d.color || color(d,i) })
                .style('stroke', function(d,i) { return d.color || color(d,i) });

            // median line
            boxEnter.append('line').attr('class', 'nv-boxplot-median');

            boxplots.select('line.nv-boxplot-median')
              .watchTransition(renderWatch, 'nv-boxplot: boxplots line')
                .attr('x1', function(d,i) { return box_left(d.values.width_index); })
                .attr('y1', function(d,i) { return y(d.values.Q2); })
                .attr('x2', function(d,i) { return box_right(d.values.width_index); })
                .attr('y2', function(d,i) { return y(d.values.Q2); });

            // patched by alex: indicator for mean value
            boxEnter.append('circle').attr('class', 'nv-boxplot-mean');
            boxplots.select('circle.nv-boxplot-mean')
              .watchTransition(renderWatch, 'nv-boxplot: boxplots boxes')
                .attr('cx', function(d,i) { return x.rangeBand() * .45; })
                .attr('cy', function(d,i) { return y(d.values.mean)-5; })
                .attr('r', '3');

            // patched by sfl: seperator between main and specific graphs
            // (rectangle which looks like two lines due to overlaying with top
            // and bottom lines)
            // currently placed absolutely to avoid ridiculous amount of work to determine actual position
            // which is = width of first graph + half of subgraphSpace - half of width of the seperator rect)
            container.append('rect')
                .attr('style', 'fill: #fcfcfc; stroke: #e5e5e5;')
                .attr('x', 280)
                .attr('y', 0)
                .attr('width', 10)
                .attr('height', availableHeight);

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('nv-boxplot immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        maxBoxWidth: {get: function(){return maxBoxWidth;}, set: function(_){maxBoxWidth=_;}},
        subgraphSpace: {get: function(){return subgraphSpace;}, set: function(_){subgraphSpace=_;}},
        minBoxWidth: {get: function(){return minBoxWidth;}, set: function(_){minBoxWidth=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        // rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};


nv.models.anacodeboxPlotChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var boxplot = nv.models.anacodeboxPlot()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        ;

    var margin = {top: 15, right: 10, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.getColor()
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , staggerLabels = false
        , tooltip = nv.models.tooltip()
        , x
        , y
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'beforeUpdate', 'renderEnd')
        , duration = 250
        , minBoxWidth = 34  // patched by sfl: added minBoxWidth option
        , subgraphSpace = 76  // patched by sfl: added subgraphSpace option
        ;

    xAxis
        .orient('bottom')
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickFormat(d3.format(',.1f'))
    ;
    
    tooltip.duration(0);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(boxplot);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                dispatch.beforeUpdate();
                container.transition().duration(duration).call(chart);
            };
            chart.container = this;

            // Display No Data message if there's nothing to show. (quartiles required at minimum)
            if (!data || !data.length || 
                    !data.filter(function(d) { return d.values.hasOwnProperty("Q1") && d.values.hasOwnProperty("Q2") && d.values.hasOwnProperty("Q3"); }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = boxplot.xScale();
            y = boxplot.yScale().clamp(true);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-boxPlotWithAxes').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-boxPlotWithAxes').append('g');
            var defsEnter = gEnter.append('defs');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis')
                .append('g').attr('class', 'nv-zeroLine')
                .append('line');

            gEnter.append('g').attr('class', 'nv-barsWrap');

            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Main Chart Component(s)
            boxplot
                .width(availableWidth)
                .height(availableHeight);

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            barsWrap.transition().call(boxplot);

            defsEnter.append('clipPath')
                .attr('id', 'nv-x-label-clip-' + boxplot.id())
                .append('rect');

            g.select('#nv-x-label-clip-' + boxplot.id() + ' rect')
                .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
                .attr('height', 16)
                .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis').call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                if (staggerLabels) {
                    xTicks
                        .selectAll('text')
                        .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')' })
                }
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( Math.floor(availableHeight/36) ) // can't use nv.utils.calcTicksY with Object data
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis').call(yAxis);
            }

            // Zero line
            g.select(".nv-zeroLine line")
                .attr("x1",0)
                .attr("x2",availableWidth)
                .attr("y1", y(0))
                .attr("y2", y(0))
            ;

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------
        });

        renderWatch.renderEnd('nv-boxplot chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    boxplot.dispatch.on('elementMouseover.tooltip', function(evt) {
        tooltip.data(evt).hidden(false);
    });

    boxplot.dispatch.on('elementMouseout.tooltip', function(evt) {
        tooltip.data(evt).hidden(true);
    });

    boxplot.dispatch.on('elementMousemove.tooltip', function(evt) {
        tooltip.position({top: d3.event.pageY, left: d3.event.pageX})();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.boxplot = boxplot;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.tooltip = tooltip;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        minBoxWidth:    {get: function(){return minBoxWidth;}, set: function(_){minBoxWidth=_;}},  // patched by sfl: added minBoxWidth option
        subgraphSpace:    {get: function(){return subgraphSpace;}, set: function(_){subgraphSpace=_;}},  // patched by sfl: added subgraphSpace option

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            boxplot.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            boxplot.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }}
    });

    nv.utils.inheritOptions(chart, boxplot);
    nv.utils.initOptions(chart);

    // patched by sfl: render_end handler to execute post d3js changes to the
    // graph and other page elements, related to the graph
    nv.dispatch.on('render_end', function(e) {
        updateGraphLayout();
    });

    return chart;
}
